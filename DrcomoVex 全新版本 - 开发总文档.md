# 📁 DrcomoVex 全新版本 - 开发总文档

## **版本**: 1.0.0 (代号: "直觉")

## **文档状态**: 最终草案

## **定稿日期**: 2025年8月3日

-----

### 1\. 项目总览

#### 1.1 开发背景

本项目是对现有变量管理系统的一次彻底的、颠覆性的重写。原有系统及市场上同类产品，普遍存在配置复杂、类型系统僵化、指令反直觉、动态能力孱弱等问题，极大地限制了服主创造复杂、动态玩法的能力。在经历了数次失败的、妥协的“重构”尝试后，项目组最终决定，必须彻底抛弃历史包袱，基于“极致灵活、高度智能”的全新设计哲学，从零开始打造一个真正属于下一代的变量管理框架。

#### 1.2 问题定义与核心目标

  * **问题定义**:

    1.  **高学习成本**: 用户需要学习并严格遵守开发者预设的、复杂的变量类型系统和配置规则。
    2.  **低灵活性**: 变量的行为被其“类型”锁死，无法轻松地为同一个变量赋予多种行为特征（例如，一个数值变量无法直接被设定为周期性重置）。
    3.  **弱动态性**: 传统变量系统仅能存储静态值，无法响应服务器或玩家状态的实时变化。
    4.  **指令操作繁琐**: 指令功能单一，不支持动态参数，实现一个简单的数值增减都需要多次指令调用。

  * **核心目标**:

    1.  **实现“零类型”配置**：打造一个能根据配置项智能推断变量行为的系统，将`type`字段变为一个可选的、用于增强校验的辅助项。
    2.  **提供“全能”指令**：设计一个功能高度集成的指令系统，核心指令（如`add`）能够自适应处理不同类型的操作（数值运算、列表追加、文本拼接），并直接支持动态占位符。
    3.  **贯彻“万物皆可动态”**：确保所有关键配置（`initial`, `min`, `max`）都能无差别地支持 PlaceholderAPI 和内部变量引用。
    4.  **达成“极致简洁”**：以最少的配置，实现最强大的功能，将用户的心智负担降到最低。

#### 1.3 功能简要概述

DrcomoVex 新版本是一个基于直觉设计的变量管理引擎。其核心功能包括：智能的变量行为推断、支持动态值的全能指令系统、可配置的周期性重置机制、以及一个全面支持占位符的高度动态化配置方案。

#### 1.4 项目目标与预期达成效果

  * **项目目标**: 交付一个在灵活性、易用性、功能强大性上，全面超越当前市面上所有同类产品的变量管理插件。
  * **预期效果**:
      * **对于用户**: 能够仅凭直觉和一份极其简洁的配置文件，就能独立设计并实现复杂的、动态的、有趣的服务器玩法，而无需编写任何代码或学习复杂的系统。
      * **对于系统**: 插件本身具备高度的健壮性、性能和可扩展性，其核心逻辑清晰、易于维护和二次开发。

#### 1.5 适用场景及目标用户群体

  * **适用场景**:
      * **RPG/MMO 服务器**: 构建动态属性、技能冷却、副本计数等。
      * **生存/经济服务器**: 设计动态物价、周期性资源刷新、玩家商业技能等级。
      * **小游戏/竞技服务器**: 实现段位积分、连胜记录、每日/每周排行榜。
      * **任何寻求玩法创新的服务器**。
  * **目标用户**:
      * 追求高自由度和玩法深度的 Minecraft 服务器管理员（服主）。
      * 希望有一个强大且易于集成的变量系统作为其插件开发基础的插件开发者。

-----

### 2\. 模块功能结构

本项目在逻辑上可划分为三大核心功能模块，它们协同工作，构成了完整的系统。

#### **模块一：配置解析与变量定义核心 (Config & Definition Core)**

  * **功能描述**:
    该模块是系统的“大脑”，负责在插件启动或重载时，读取并解析 `variables.yml` 配置文件。它的核心职责是理解用户的配置意图，为每一个变量构建一个包含其所有行为特征的“定义对象 (VariableDefinition)”。它必须实现“智能推断”和“可选类型校验”的核心逻辑。
  * **输入/输出说明**:
      * **输入**: `/plugins/DrcomoVEX/variables.yml` 文件内容。
      * **输出**: 一个全局唯一的、线程安全的 `VariableRegistry` (变量注册表)，其中存储了所有 `VariableDefinition` 对象，供其他模块查询。
  * **内部逻辑流程**:
    1.  **加载文件**: 读取 `variables.yml`。
    2.  **遍历变量**: 遍历 `variables:` 下的每一个变量键（如 `player_money`）。
    3.  **为每个变量构建 Definition**:
        ```text
        For each variable_key in config:
        |-- 1. 创建一个新的、空的 VariableDefinition 对象。
        |-- 2. 读取所有存在的字段 (name, scope, type, initial, min, max, cycle) 并存入 Definition。
        |-- 3. **执行智能推断与校验**:
        |   |-- a. IF `type` 字段不存在:
        |   |   |-- 检查 `initial` 值的格式：
        |   |   |   |-- IF 是YAML列表格式 -> 推断类型为 LIST。
        |   |   |   |-- IF 看起来像数字 -> 推断类型为 DOUBLE/INT。
        |   |   |   |-- ELSE -> 推断类型为 STRING。
        |   |   |-- 记录推断出的类型到 Definition 中。
        |   |-- b. IF `type` 字段存在:
        |   |   |-- 将用户定义的类型记录到 Definition 中。
        |   |   |-- **执行约束校验**:
        |   |   |   |-- IF type 是 STRING 且配置了 `min` 或 `max` -> 在控制台打印 WARN 日志，提示该约束无效。
        |   |-- c. 检查 `initial`, `min`, `max` 是否包含占位符 (`%...%` 或 `${...}`) -> 若包含，则在 Definition 中标记为“动态”。
        |   |-- d. 检查是否存在 `cycle` 字段 -> 若存在，则在 Definition 中标记为“周期性”。
        |-- 4. 将构建完成的 Definition 对象存入 `VariableRegistry`。
        ```
  * **模块依赖与执行约束**:
      * **依赖**: `SnakeYAML` 库 (由 Bukkit 提供)。
      * **执行约束**: 该模块的 `reload` 方法应在插件 `onEnable` 和执行 `/vex reload` 指令时被调用。读取和解析过程应快速完成，避免阻塞主线程。

#### **模块二：核心逻辑与数据服务 (Logic & Data Service)**

  * **功能描述**:
    这是系统的“心脏”，负责处理所有运行时的变量操作请求。它接收来自指令系统的请求，根据 `VariableRegistry` 中的定义来执行相应的业务逻辑（如数值计算、列表操作、动态解析），并与持久化层交互来存取数据。
  * **输入/输出说明**:
      * **输入**: 来自指令模块的请求，通常包含：`操作类型 (GET, SET, ADD, REMOVE, RESET)`, `目标玩家 (OfflinePlayer)`, `变量键 (String)`, `操作值 (String)`。
      * **输出**: 一个 `CompletableFuture<OperationResult>` 对象，异步地返回操作结果（成功信息或失败原因）。
  * **内部逻辑流程**:
      * **获取变量 (`getVariable`)**:
        1.  根据变量定义，判断其 `initial` 是否为动态表达式。
        2.  IF 是动态 -\> 调用**动态解析引擎**，实时计算结果并返回。
        3.  IF 是静态 -\> 从**缓存**中查询值，若未命中则查询**持久化层**，然后返回。
      * **智能增加 (`addVariable`)**:
        1.  获取变量当前值。
        2.  根据变量定义或值的特征，判断其类型。
        3.  IF 是数值 -\> 解析输入值为数字（支持负数和占位符），执行数学加法。
        4.  IF 是列表 -\> 将输入值追加到列表。
        5.  IF 是文本 -\> 执行字符串拼接。
        6.  **执行后校验**: 检查新生成的值是否符合 `min`/`max` 约束。
        7.  IF 通过 -\> 保存新值到持久化层。
        8.  IF 不通过 -\> 返回错误信息。
  * **模块依赖与执行约束**:
      * **依赖**: `VariableRegistry`, `持久化模块`, `动态解析引擎`。
      * **执行约束**: 所有方法都必须是**完全异步**的，返回 `CompletableFuture`，确保不阻塞调用者线程。

#### **模块三：指令与外部接口 (Command & API Interface)**

  * **功能描述**:
    这是系统的“门面”，是用户和开发者与 DrcomoVex 交互的唯一入口。它负责解析用户输入的 `/vex` 指令，调用核心逻辑服务，并将结果格式化后发送给用户。
  * **输入/输出说明**:
      * **输入**: 玩家或控制台输入的原始指令字符串数组 (`String[] args`)。
      * **输出**: 发送给 `CommandSender` 的、格式化好的消息字符串。
  * **内部逻辑流程**:
    1.  **注册指令**: 在 `plugin.yml` 中注册 `/vex` 指令。
    2.  **指令处理器 (`onCommand`)**:
        ```text
        Function onCommand(sender, command, args):
        |-- 1. 权限检查。
        |-- 2. 解析子命令 (get, set, add, ...)。
        |-- 3. 解析参数和标志 (变量名, 目标玩家, 值)。
        |-- 4. **调用核心逻辑服务**:
        |   |-- e.g., coreLogicService.addVariable(player, key, value);
        |-- 5. **处理异步结果**:
        |   |-- future.thenAccept(result -> {
        |   |   |-- IF result.isSuccess():
        |   |   |   |-- 从 messages.yml 读取成功消息模板。
        |   |   |   |-- 格式化并发送消息给 sender。
        |   |   |-- ELSE:
        |   |   |   |-- 发送 result.getErrorMessage()。
        |   |-- });
        ```
  * **模块依赖与执行约束**:
      * **依赖**: `核心逻辑服务`, `Bukkit API`, `消息格式化服务 (MessageService)`。
      * **执行约束**: 指令的执行必须是异步的。向玩家发送消息的回调操作，必须确保在主线程中执行。

-----

### 3\. 数据结构与状态管理

#### 3.1 核心数据结构说明

  * **`VariableDefinition` (只读定义对象)**:
      * 在插件加载时根据 `variables.yml` 创建，存储在 `VariableRegistry` 中。
      * 包含一个变量的所有静态配置信息：`name`, `scope`, `type`(明确或推断), `initial`, `min`, `max`, `cycle`。
      * 包含布尔标志位：`isDynamic`, `isPeriodic`。
      * **它是不可变的，是所有运行时逻辑的“规则书”。**
  * **`VariableRuntimeValue` (运行时值对象 - 内存中)**:
      * 这是一个概念上的对象，物理上可能就是一个存在于缓存中的 `String` 或 `List<String>`。
      * 代表一个玩家某个变量的**当前值**。
  * **`OperationResult` (操作结果对象)**:
      * 由核心逻辑服务返回，用于封装操作的成功/失败状态及相关信息。
      * 包含 `boolean success` 和 `String message` 两个字段。
  * **缓存体系**:
      * **值缓存 (Value Cache)**: 使用 `Caffeine` 库。Key 为 `playerUUID:variableKey`，Value 为 `String` 或 `List<String>`。用于缓存从数据库中读取的静态变量值，大幅减少数据库读取。
      * **解析缓存 (Parse Cache)**: 使用 `Caffeine` 库。Key 为 `playerUUID:expressionString`，Value 为解析后的最终结果 `String`。用于缓存动态表达式的计算结果。

#### 3.2 状态生命周期管理

  * **变量值的创建**:
      * 当一个玩家首次与一个变量交互（`get`, `set`, `add` 等），且数据库中不存在该玩家此变量的数据时，系统会使用 `VariableDefinition` 中的 `initial` 值作为其初始值。
      * 如果 `initial` 是动态的，则会实时计算出初始值。
  * **变量值的失效/重置 (状态转移)**:
    1.  **周期性重置**: 对于配置了 `cycle` 的变量，一个独立的**调度器服务 (Scheduler Service)** 会定时检查。当到达重置时间点，它会调用核心逻辑服务的 `resetVariable` 方法，删除该变量的当前值，使其回退到 `initial` 状态。
    2.  **手动重置**: 用户执行 `/vex reset` 指令，会直接触发上述的重置流程。
  * **缓存的失效逻辑**:
      * 值缓存和解析缓存都采用**基于时间的失效策略 (TTL - Time To Live)**，例如 5-10 分钟。
      * 当执行任何“写”操作（`set`, `add`, `remove`, `reset`）成功后，会**立即、主动地**使对应的值缓存和解析缓存条目失效，确保数据一致性。

-----

### 4\. 配置与扩展机制

#### 4.1 外部配置支持

  * **支持格式**: `YAML`。
  * **核心配置文件**: `/plugins/DrcomoVEX/variables.yml`。
  * **分布式配置**: 支持在 `/plugins/DrcomoVEX/variables/` 目录下创建任意 `.yml` 文件，插件会自动加载所有这些文件，方便模块化管理。

#### 4.2 配置项说明

| 字段名称 | 含义 | 默认值 | 作用范围 |
| :--- | :--- | :--- | :--- |
| `name` | 变量的显示名称 | `null` | 显示/UI |
| `scope` | 作用域 (`player`/`global`) | `"player"` | 数据归属 |
| `type` | 变量类型 (`INT`/`DOUBLE`/`STRING`/`LIST`) | 智能推断 | 逻辑校验与约束 |
| `initial` | 初始值，或动态表达式 | `null` | 变量默认状态与动态行为 |
| `min` | 最小值/最小长度 | `null` | 运行时约束 |
| `max` | 最大值/最大长度 | `null` | 运行时约束 |
| `cycle` | 重置周期 (`DAILY`, `WEEKLY`, `MONTHLY`, `YEARLY`, Cron) | `null` | 周期性行为 |

#### 4.3 扩展机制设计

  * **热更新**: 系统必须支持通过 `/vex reload` 指令，在不重启服务器的情况下，重新加载并应用所有 `variables.yml` 的配置变更。
      * **实现逻辑**: `reload` 指令会触发 `Config & Definition Core` 模块的 `reload` 方法，该方法会清空旧的 `VariableRegistry` 并重新执行完整的加载和解析流程。同时，会通知相关的服务（如缓存服务）清空所有缓存。
  * **动态加载**: 分布式配置机制本身就是一种动态加载。插件启动时会扫描 `variables/` 目录，加载所有找到的 `.yml` 文件。
  * **未来扩展 - 规则注册**: 预留接口，允许其他开发者通过 API 注册新的 `cycle` 类型或新的函数用于动态表达式计算。

-----

### 5\. 功能实现说明

本项目基于“直觉设计”哲学，旨在提供一个极度灵活且强大的变量管理系统。以下是核心功能的实现说明。

#### 5.1 已实现的功能点清单

1.  **智能变量行为系统**:

      * **自动类型推断**: 系统在加载配置时，会根据 `initial` 值的格式（数字、列表、文本）自动推断变量的基础类型。
      * **可选类型定义**: 用户可通过 `type` 字段 (`INT`, `DOUBLE`, `STRING`, `LIST`) 对变量进行显式定义，以获得更严格的类型校验和配置检查。
      * **行为由配置激活**: 变量是否为“周期性”或“动态”，完全由是否存在 `cycle` 字段或 `initial` 值是否为表达式来决定，移除了僵化的分类。

2.  **全能指令系统**:

      * **智能 `add` 指令**:
          * 支持对数值类型变量进行数学加法。
          * 支持直接使用**负数**实现减法操作。
          * 支持在`<值>`参数中直接使用 **PlaceholderAPI 占位符**，实现动态数值增减。
          * 支持对列表类型变量追加元素。
          * 支持对文本类型变量进行字符串拼接。
      * **智能 `remove` 指令**:
          * 支持从列表类型变量中移除指定元素。
          * 支持从文本类型变量中移除指定子字符串。
      * **清晰的 `reset` 指令**: 提供独立的 `/vex reset` 指令，用于将变量恢复至其 `initial` 状态。

3.  **万物皆可动态**:

      * **全面占位符支持**: `initial`, `min`, `max` 三个核心配置项均支持 PlaceholderAPI 占位符 (`%...%`) 和内部变量引用 (`${...}`)。
      * **实时解析**: 所有包含动态占位符的变量，在被获取时都会进行实时解析，确保返回最新、最准确的值。

4.  **周期性重置机制**:

      * **多种预设周期**: 支持 `DAILY`, `WEEKLY`, `MONTHLY`, `YEARLY` 四种常用重置周期。
      * **高级 Cron 支持**: 支持标准的 Cron 表达式，允许用户定义任意复杂的重置调度。
      * **精确的时间处理**: 基于 `ZonedDateTime`，确保时区正确，并能精确处理跨月、跨年、闰年等情况。

5.  **健壮的配置加载与管理**:

      * **分布式配置**: 支持在 `variables/` 目录下创建多个 `.yml` 文件进行模块化管理。
      * **智能约束校验**: 在加载配置时，若用户为不适用的类型（如 `STRING`）配置了约束（如 `min`），系统会打印警告日志，但不会阻止插件加载。
      * **热重载**: 支持通过 `/vex reload` 指令安全地、即时地应用所有配置变更。

#### 5.2 功能使用方式与触发条件

  * **变量定义**:
      * **触发条件**: 编辑 `/plugins/DrcomoVEX/variables.yml` 或 `variables/` 目录下的任意 `.yml` 文件，并执行 `/vex reload`。
      * **使用方式**: 参照配置章节的字段清单，为变量添加所需的配置项。
  * **变量操作**:
      * **触发条件**: 在游戏聊天栏或服务器控制台输入 `/vex` 指令。
      * **使用方式**: 参照操作流程章节的指令格式，使用 `get`, `set`, `add`, `remove`, `reset` 等子命令。
  * **周期性重置**:
      * **触发条件**: 系统内部的调度器会自动触发。
      * **使用方式**: 只需在配置文件中为变量添加 `cycle` 字段即可自动启用。

#### 5.3 特别注意的操作或边界条件

  * **数值与文本的转换**: `add` 指令在执行数学运算前，会尝试将变量的当前值和输入值都转换为数字。如果任一转换失败（例如，当前值为"Hello"），操作将失败并返回明确的错误提示。
  * **约束的执行时机**: `min`/`max` 约束会在任何改变变量值的操作（`set`, `add`）**执行成功后**进行检查。若结果超出约束，整个操作将被视为失败，变量的值不会发生改变。
  * **动态值的性能**: 虽然系统有缓存和安全机制，但如果在高频调用的动态表达式中使用了性能较差的第三方 PlaceholderAPI 占位符，仍可能对服务器性能产生影响。请谨慎选择在动态表达式中使用的占位符。

-----

### 6\. 关键流程图与交互逻辑

#### 6.1 用户视角交互流程：使用 `add` 指令为玩家增加金币

1.  **入口**: 玩家 `PlayerA` 在聊天栏输入指令：
    ```
    /vex add player_money 100 -p:PlayerB
    ```
2.  **系统解析**: 指令处理器模块 (`D03`) 接收指令。
      * 解析出子命令: `add`
      * 解析出变量名: `player_money`
      * 解析出操作值: `"100"`
      * 解析出目标玩家: `PlayerB`
3.  **权限校验**: 系统检查 `PlayerA` 是否拥有 `drcomovex.command.add` 权限。
      * **IF** 无权限 -\> **[异常处理]** 向 `PlayerA` 发送“无权限”提示消息，流程结束。
4.  **调用核心逻辑**: 指令处理器调用核心逻辑服务 (`D02`) 的 `addVariable` 方法，并传入解析好的参数。
5.  **异步处理与响应**:
      * `D02` 服务在后台线程中执行所有逻辑（获取旧值、计算、校验、保存）。
      * `D03` 模块不等待，立即释放主线程。
      * `D02` 完成后，返回一个包含成功或失败信息的结果对象。
      * `D03` 在主线程的回调中接收到结果。
          * **IF** 成功 -\> 从 `messages.yml` 读取成功消息，格式化后发送给 `PlayerA`。
          * **IF** 失败 -\> 从结果对象中获取错误原因，格式化后发送给 `PlayerA`。

#### 6.2 系统视角流程：处理 `addVariable` 请求

```text
Function addVariable(player, key, valueStr):
|-- 1. **获取变量定义**: 从 VariableRegistry 获取 `key` 对应的 VariableDefinition。
|-- 2. **获取变量当前值 (currentValue)**:
|   |-- 异步从缓存或持久化层查询 `player` 的 `key` 变量的当前值。
|-- 3. **解析操作值 (addValue)**:
|   |-- 因为是 `add` 指令，尝试将 `valueStr` (可能含占位符) 解析为数字。
|   |-- a. 使用动态解析引擎解析 `valueStr` 中的占位符。
|   |-- b. 将解析后的字符串尝试转换为 Double。
|   |-- c. **IF** 转换失败 -> **[异常处理]** 返回 OperationResult.error("无效的数值")。
|-- 4. **执行智能操作**:
|   |-- a. 获取变量的 `type` (明确定义的或推断的)。
|   |-- b. **SWITCH (type)**:
|   |   |-- **CASE (INT, DOUBLE)**:
|   |   |   |-- 尝试将 `currentValue` 转换为数字。
|   |   |   |-- **IF** 失败 -> **[异常处理]** 返回 OperationResult.error("无法对文本变量执行数学运算")。
|   |   |   |-- 计算 `newValue = currentValue + addValue`。
|   |   |-- **CASE (LIST)**:
|   |   |   |-- 将 `currentValue` 解析为列表，追加 `valueStr`，生成 `newValue`。
|   |   |-- **CASE (STRING)**:
|   |   |   |-- `newValue = currentValue + valueStr`。
|-- 5. **执行约束校验 (validateConstraints)**:
|   |-- 传入 `newValue` 和 `definition`。
|   |-- a. 检查 `newValue` 是否在 `definition.min` 和 `definition.max` (均支持动态解析) 的范围内。
|   |-- b. **IF** 超出约束 -> **[异常处理]** 返回 OperationResult.error("值超出约束范围")。
|-- 6. **触发 Pre-Change 事件**:
|   |-- 创建 PreVariableChangeEvent，交由事件广播器处理。
|   |-- **IF** 事件被取消 -> **[异常处理]** 返回 OperationResult.error("操作被其他插件取消")。
|-- 7. **持久化**:
|   |-- 异步调用持久化模块，将 `newValue` 保存到数据库。
|   |-- 同时，使相关缓存失效。
|-- 8. **触发 Post-Change 事件**:
|   |-- 异步广播 PostVariableChangeEvent。
|-- 9. **返回成功**: 返回 OperationResult.success("操作成功")。
```

-----

### 7\. 安全性与稳定性考量

#### 7.1 数据一致性保障

  * **写操作的缓存策略**: 任何写操作（`set`, `add`, `remove`, `reset`）成功后，都必须立即主动失效（`invalidate`）相关的所有缓存条目（值缓存、解析缓存），以防止读到脏数据。
  * **并发环境**:
      * **写后队列 (Write-Behind Queue)**: 虽然当前设计为直接异步写入，但可预留升级空间。将写操作放入一个线程安全的 `ConcurrentLinkedQueue`，由单个后台线程批量、顺序地执行数据库写入，可以彻底避免数据库层面的并发写冲突。
      * **原子操作**: 对于“先读后写”的操作（如 `add`），应在逻辑层设计为原子性操作。虽然不使用数据库锁，但通过异步回调链和 `CompletableFuture` 的组合，可以保证单个操作流程的完整性，避免竞态条件。

#### 7.2 用户操作风险规避

  * **权限节点**: 所有指令的执行，必须首先检查执行者是否拥有对应的、设计精细的权限节点（例如 `drcomovex.command.set`, `drcomovex.admin.reload`），防止越权操作。
  * **防刷处理**: 对于可能被滥用的指令（如通过 `add` 指令高频刷物品），可在核心逻辑服务中预留一个简单的速率限制器（Rate Limiter）接口，允许服主在 `config.yml` 中配置某些指令的调用频率限制。
  * **输入验证**: 指令模块作为第一道防线，必须对用户输入进行基础的格式和存在性校验（例如，检查是否提供了变量名），并返回对用户友好的错误提示，避免将格式错误的请求传递给后端服务。

#### 7.3 系统异常恢复与资源释放

  * **超时机制**: 所有依赖外部服务（数据库查询、PAPI解析）的异步操作，都必须设置合理的超时时间（例如 `CompletableFuture.orTimeout`）。一旦超时，操作应立即失败并返回错误，防止线程被无限期阻塞。
  * **回滚机制**: 对于多步骤的写操作（未来可能出现），应考虑引入事务。虽然 `D01` 的单次写入是原子的，但如果未来有“同时修改多个变量”的需求，则必须将这些操作包裹在数据库事务中，确保要么全部成功，要么全部失败。
  * **资源释放**: 数据库连接池（如 `HikariCP`）必须在插件 `onDisable` 时被明确关闭，所有后台调度任务（如周期性重置检查）也必须被安全地取消，防止内存和线程泄漏。

-----

### 8\. 性能优化与可维护性设计

#### 8.1 控制性能开销

  * **延迟加载**: 玩家变量数据不会在玩家加入时一次性全部加载，而是在首次被请求时，通过核心逻辑服务按需、异步地从数据库加载。
  * **多级缓存策略**:
      * **值缓存**: 缓存从数据库读取的静态变量值。
      * **解析缓存**: 缓存动态表达式的计算结果。
      * 这两层缓存能极大地减少对数据库的直接访问和重复的复杂计算。
  * **异步化一切**: 整个系统的核心原则是“异步优先”。任何可能耗时的操作（数据库I/O、文件读写、网络请求、复杂计算）都必须被封装在 `CompletableFuture` 中，在后台线程池执行，以保证服务器主线程的绝对流畅。

#### 8.2 模块间解耦策略

  * **服务化设计**: 将核心功能封装成独立的服务（如 `VariableLogicService`, `PersistenceService`），模块间通过调用服务接口进行通信，而不是直接访问彼此的内部实现。
  * **依赖注入**: 在插件启动时，由主类 `DrcomoVEX` 负责实例化所有核心服务，并处理它们之间的依赖关系（例如，将 `PersistenceService` 实例注入到 `VariableLogicService` 中）。这避免了模块间的硬编码依赖。
  * **事件驱动**: 模块间的状态变更通知，应通过一个统一的事件总线进行广播。例如，`D02` 在变量变更后，只需发布一个 `PostVariableChangeEvent`，而无需关心哪些模块（如 `D03` 或其他插件）需要这个信息。

#### 8.3 可维护性与版本升级

  * **清晰的包结构**: 严格按照模块职责划分 Java 包（`cn.drcomo.persistence`, `cn.drcomo.variable.logic`, `cn.drcomo.command` 等）。
  * **接口隔离**: 对外暴露的 API 应通过专门的接口定义，并考虑在包名中加入版本号（如 `api.v1`），为未来推出不兼容的 `v2` 版本提供平滑过渡。
  * **代码注释与文档**: 所有核心服务、公共方法和复杂逻辑，都必须配有清晰、标准的 JavaDoc 注释，解释其功能、参数、返回值和线程模型。

-----

### 9\. 测试设计建议

#### 9.1 推荐覆盖的测试场景

  * **单元测试 (Unit Tests)**:
      * **动态解析引擎**: 重点测试各种边界情况，包括合法的数学表达式、PAPI占位符、内部变量引用、嵌套引用、循环引用（预期失败）、超深递归（预期失败）。
      * **周期性重置逻辑**: 测试 `Cycle` 枚举对各种临界时间点（如月末、年末、闰年）的 `next()` 计算是否精确。
      * **配置解析器**: 测试对各种合法及非法 `variables.yml` 配置的解析能力和错误处理能力。
  * **集成测试 (Integration Tests)**:
      * **完整逻辑链路**: 测试从“指令输入”到“数据库落盘”的完整流程。例如，模拟一个 `/vex add` 指令，断言最终数据库中的值是否正确，以及相关的缓存是否被正确更新。
      * **数据库兼容性**: 使用内存数据库（如 H2）模拟 MySQL 和 SQLite 两种模式，运行同一套测试用例，确保 DAO 层的 SQL 兼容性。
  * **端到端测试 (End-to-End Tests)**:
      * 在一个真实的（或基于 MockBukkit 的）服务器环境中，模拟玩家执行所有 `/vex` 指令，并断言其收到的游戏内消息是否符合预期。

#### 9.2 建议断言点与自动化策略

  * **断言点**:
      * **方法返回值**: 断言核心逻辑服务的方法返回的 `OperationResult` 是否符合预期。
      * **数据库状态**: 在写操作测试后，直接查询数据库，断言数据是否被正确写入/更新/删除。
      * **缓存状态**: 断言缓存中是否存在预期的键值对，或在写操作后是否被成功失效。
      * **事件触发**: 使用 Mockito 等框架，断言事件广播器是否被以正确的参数调用。
  * **自动化策略**:
      * **使用 Mockito**: Mock 掉外部依赖（如 `PersistenceService`, `PlaceholderAPI`），专注于测试单个模块的内部逻辑。
      * **使用 MockBukkit**: 创建一个模拟的 Bukkit 服务器环境，用于测试需要与服务器 API 交互的部分（如指令注册、事件监听）。
      * **CI/CD 集成**: 将所有测试集成到持续集成流水线中（如 GitHub Actions），确保每次代码提交都会自动运行完整的测试套件，保证代码质量。

-----

### 10\. 关键代码结构建议

#### 10.1 核心服务伪代码

  * **`VariableLogicService.java`**:

    ```java
    public class VariableLogicService {
        private final PersistenceService persistence;
        private final VariableRegistry registry;
        private final DynamicParser parser;

        public CompletableFuture<String> getVariable(OfflinePlayer player, String key) {
            // ... 作用域链解析、缓存查询、动态表达式处理 ...
        }

        public CompletableFuture<OperationResult> addVariable(OfflinePlayer player, String key, String valueToAdd) {
            // ... 异步获取当前值 -> 智能判断类型 -> 执行操作 -> 约束校验 -> 触发事件 -> 持久化 ...
        }
    }
    ```

  * **`DynamicParser.java`**:

    ```java
    public class DynamicParser {
        public CompletableFuture<String> parse(OfflinePlayer player, String expression) {
            // ... 缓存检查 -> 异步执行 parseWithSafety ...
        }

        private String parseWithSafety(OfflinePlayer player, String expression, int depth, Set<String> stack) {
            // 1. 安全检查 (深度、循环)
            // 2. 解析 PAPI
            // 3. 递归解析内部变量 ${...}
            // 4. 解析数学公式
        }
    }
    ```

#### 10.2 外部库使用说明

  * **`com.github.ben-manes.caffeine:caffeine`**:
      * **推荐用法**: 用于构建高性能的内存缓存。
        ```java
        Cache<String, String> valueCache = Caffeine.newBuilder()
                .expireAfterWrite(Duration.ofMinutes(10))
                .maximumSize(10000)
                .build();
        ```
      * **使用原因**: 提供了丰富的缓存策略（基于时间、大小、引用），性能优异，是现代 Java 项目缓存实现的首选。
  * **`org.apache.commons.math3:commons-math3` (可选)**:
      * **推荐用法**: 可用于替代手写的数学表达式求值器，提供更强大、更安全的计算能力。
      * **使用原因**: 成熟、稳定，支持更复杂的数学函数。如果未来需要支持更高级的数学运算，引入此库是最佳选择。

-----

### 11\. 外部依赖接口

  * **`PlaceholderAPI`**:
      * **调用方式**: 通过 `DrcomoCoreLib` 提供的 `PlaceholderAPIUtil` 工具类进行调用。
        ```java
        String parsedString = placeholderAPIUtil.parse(player, "%player_name% is level %player_level%");
        ```
      * **权限控制**: 无需特殊权限。
      * **示例**: 在动态表达式中，用户可以直接写入 `%player_level%`，系统内部会通过上述方式进行解析。

-----

### 12\. 开发注意事项

  * **线程模型是核心**: 开发者必须时刻铭记整个系统的异步特性。任何对核心逻辑服务的调用都将返回 `CompletableFuture`，必须通过回调链来处理结果，**严禁在主线程中调用 `.join()` 或 `.get()`**（PAPI占位符注册等特殊情况除外，且需明确注释其风险）。
  * **配置的向后兼容性**: 在未来迭代中，如果需要修改 `variables.yml` 的配置结构，必须考虑向后兼容。应编写代码来自动识别旧版本的配置格式，并将其平滑地迁移到新格式，或至少在日志中给出清晰的迁移指导。
  * **日志的重要性**: 在所有关键路径、异常捕获点、异步任务的开始和结束，都应打印详细的、带上下文信息的 `DEBUG` 或 `INFO` 日志。这对于排查在复杂的异步环境中出现的问题至关重要。
  * **API的稳定性**: 一旦为开发者设计并发布了公共 API，就应尽最大努力保持其稳定。任何不兼容的改动都应在新版本号（如`v2`）的包下进行，并为旧 API 提供一个至少维持数个大版本的废弃过渡期。